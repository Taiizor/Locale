# Custom Format Examples

Learn how to create and register your own localization format handlers.

## Creating a Custom Format

To create a custom format, implement the `ILocalizationFormat` interface:

```csharp
using Locale.Formats;
using Locale.Models;

namespace MyApp.Localization;

/// <summary>
/// Custom format handler for properties files (.properties)
/// </summary>
public sealed class PropertiesLocalizationFormat : LocalizationFormatBase
{
    public override string FormatId => "properties";
    
    public override IReadOnlyList<string> SupportedExtensions => 
        new[] { ".properties" };
    
    public override LocalizationFile Parse(Stream stream, string? filePath = null)
    {
        using var reader = new StreamReader(stream);
        var entries = new List<LocalizationEntry>();
        string? line;
        int lineNumber = 0;
        
        while ((line = reader.ReadLine()) != null)
        {
            lineNumber++;
            
            // Skip empty lines and comments
            if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith('#'))
                continue;
            
            // Parse key=value pairs
            int separatorIndex = line.IndexOf('=');
            if (separatorIndex <= 0)
                continue;
            
            string key = line[..separatorIndex].Trim();
            string value = line[(separatorIndex + 1)..].Trim();
            
            // Unescape special characters
            value = UnescapeValue(value);
            
            entries.Add(new LocalizationEntry
            {
                Key = key,
                Value = value
            });
        }
        
        return new LocalizationFile
        {
            FilePath = filePath ?? "unknown",
            Entries = entries
        };
    }
    
    public override void Write(LocalizationFile file, Stream stream)
    {
        using var writer = new StreamWriter(stream);
        
        // Write header comment
        writer.WriteLine("# Generated by Locale");
        writer.WriteLine($"# File: {Path.GetFileName(file.FilePath)}");
        writer.WriteLine($"# Culture: {file.Culture ?? "unknown"}");
        writer.WriteLine($"# Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        writer.WriteLine();
        
        // Write entries
        foreach (var entry in file.Entries.OrderBy(e => e.Key))
        {
            // Write comment if present
            if (!string.IsNullOrEmpty(entry.Comment))
            {
                writer.WriteLine($"# {entry.Comment}");
            }
            
            string escapedValue = EscapeValue(entry.Value ?? "");
            writer.WriteLine($"{entry.Key}={escapedValue}");
        }
    }
    
    private static string UnescapeValue(string value)
    {
        return value
            .Replace("\\n", "\n")
            .Replace("\\r", "\r")
            .Replace("\\t", "\t")
            .Replace("\\\\", "\\");
    }
    
    private static string EscapeValue(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
```

## Registering Your Custom Format

### Option 1: Register in Application Startup

```csharp
using Locale.Formats;
using MyApp.Localization;

// Register your custom format
FormatRegistry.Default.Register(new PropertiesLocalizationFormat());

// Now you can use it like any built-in format
var scanService = new ScanService();
var report = scanService.Scan("./locales", new ScanOptions 
{ 
    BaseCulture = "en",
    TargetCultures = ["tr"]
});
```

### Option 2: Create Custom Registry

```csharp
using Locale.Formats;

// Create a custom registry with only specific formats
var customRegistry = new FormatRegistry();
customRegistry.Register(new JsonLocalizationFormat());
customRegistry.Register(new YamlLocalizationFormat());
customRegistry.Register(new PropertiesLocalizationFormat());

// Use with services
var scanService = new ScanService(customRegistry);
var convertService = new ConvertService(customRegistry);
```

## Advanced Example: XML-based Format

A more complex example with XML parsing:

```csharp
using System.Xml.Linq;
using Locale.Formats;
using Locale.Models;

namespace MyApp.Localization;

/// <summary>
/// Custom format for Android string resources (strings.xml)
/// </summary>
public sealed class AndroidStringsFormat : LocalizationFormatBase
{
    public override string FormatId => "android";
    
    public override IReadOnlyList<string> SupportedExtensions => 
        new[] { ".xml" };
    
    public override bool CanHandle(string filePath)
    {
        // Only handle files named strings.xml or in values-* directories
        string fileName = Path.GetFileName(filePath);
        string dirName = Path.GetFileName(Path.GetDirectoryName(filePath) ?? "");
        
        return fileName == "strings.xml" || dirName.StartsWith("values");
    }
    
    public override LocalizationFile Parse(Stream stream, string? filePath = null)
    {
        var doc = XDocument.Load(stream);
        var entries = new List<LocalizationEntry>();
        
        var root = doc.Root;
        if (root?.Name != "resources")
        {
            throw new InvalidOperationException("Invalid Android strings.xml format");
        }
        
        foreach (var element in root.Elements("string"))
        {
            string? key = element.Attribute("name")?.Value;
            if (string.IsNullOrEmpty(key))
                continue;
            
            string? value = element.Value;
            string? comment = element.Attribute("comment")?.Value;
            
            entries.Add(new LocalizationEntry
            {
                Key = key,
                Value = value,
                Comment = comment
            });
        }
        
        // Handle string arrays
        foreach (var arrayElement in root.Elements("string-array"))
        {
            string? arrayName = arrayElement.Attribute("name")?.Value;
            if (string.IsNullOrEmpty(arrayName))
                continue;
            
            int index = 0;
            foreach (var item in arrayElement.Elements("item"))
            {
                entries.Add(new LocalizationEntry
                {
                    Key = $"{arrayName}[{index}]",
                    Value = item.Value
                });
                index++;
            }
        }
        
        return new LocalizationFile
        {
            FilePath = filePath ?? "strings.xml",
            Entries = entries
        };
    }
    
    public override void Write(LocalizationFile file, Stream stream)
    {
        var doc = new XDocument(
            new XDeclaration("1.0", "utf-8", null),
            new XElement("resources")
        );
        
        var root = doc.Root!;
        
        // Group entries by array vs single strings
        var arrays = file.Entries
            .Where(e => e.Key.Contains('['))
            .GroupBy(e => e.Key[..e.Key.IndexOf('[')])
            .ToList();
        
        var singles = file.Entries
            .Where(e => !e.Key.Contains('['))
            .OrderBy(e => e.Key)
            .ToList();
        
        // Write single strings
        foreach (var entry in singles)
        {
            var element = new XElement("string",
                new XAttribute("name", entry.Key),
                entry.Value ?? "");
            
            if (!string.IsNullOrEmpty(entry.Comment))
            {
                element.Add(new XAttribute("comment", entry.Comment));
            }
            
            root.Add(element);
        }
        
        // Write string arrays
        foreach (var array in arrays)
        {
            var arrayElement = new XElement("string-array",
                new XAttribute("name", array.Key));
            
            foreach (var entry in array.OrderBy(e => e.Key))
            {
                arrayElement.Add(new XElement("item", entry.Value ?? ""));
            }
            
            root.Add(arrayElement);
        }
        
        doc.Save(stream);
    }
}
```

## Testing Your Custom Format

Create comprehensive tests for your custom format:

```csharp
using Xunit;
using Locale.Models;
using MyApp.Localization;

namespace MyApp.Tests.Localization;

public class PropertiesLocalizationFormatTests
{
    private readonly PropertiesLocalizationFormat _format = new();
    
    [Fact]
    public void FormatId_ReturnsProperties()
    {
        Assert.Equal("properties", _format.FormatId);
    }
    
    [Fact]
    public void CanHandle_PropertiesFile_ReturnsTrue()
    {
        Assert.True(_format.CanHandle("messages.properties"));
        Assert.True(_format.CanHandle("app.en.properties"));
    }
    
    [Fact]
    public void CanHandle_NonPropertiesFile_ReturnsFalse()
    {
        Assert.False(_format.CanHandle("data.json"));
        Assert.False(_format.CanHandle("config.xml"));
    }
    
    [Fact]
    public void Parse_ValidProperties_ReturnsCorrectEntries()
    {
        string content = @"
# Comments are ignored
app.title=My Application
app.description=This is a test

# Another section
user.name=John Doe
user.email=john@example.com
";
        
        using var stream = new MemoryStream(Encoding.UTF8.GetBytes(content));
        var file = _format.Parse(stream, "test.properties");
        
        Assert.Equal(4, file.Count);
        Assert.Equal("My Application", file.GetValue("app.title"));
        Assert.Equal("John Doe", file.GetValue("user.name"));
    }
    
    [Fact]
    public void Parse_EscapedCharacters_UnescapesCorrectly()
    {
        string content = "message=Line 1\\nLine 2\\tTabbed";
        
        using var stream = new MemoryStream(Encoding.UTF8.GetBytes(content));
        var file = _format.Parse(stream);
        
        string? value = file.GetValue("message");
        Assert.Contains("\n", value);
        Assert.Contains("\t", value);
    }
    
    [Fact]
    public void Write_CreatesValidPropertiesFile()
    {
        var file = new LocalizationFile
        {
            FilePath = "test.properties",
            Entries = new List<LocalizationEntry>
            {
                new() { Key = "key1", Value = "value1" },
                new() { Key = "key2", Value = "Line 1\nLine 2" }
            }
        };
        
        using var stream = new MemoryStream();
        _format.Write(file, stream);
        
        stream.Position = 0;
        string content = new StreamReader(stream).ReadToEnd();
        
        Assert.Contains("key1=value1", content);
        Assert.Contains("key2=Line 1\\nLine 2", content);
    }
    
    [Fact]
    public void Roundtrip_PreservesData()
    {
        var original = new LocalizationFile
        {
            FilePath = "test.properties",
            Entries = new List<LocalizationEntry>
            {
                new() { Key = "app.title", Value = "Test App" },
                new() { Key = "app.desc", Value = "Multi\nLine\nText" }
            }
        };
        
        // Write
        using var writeStream = new MemoryStream();
        _format.Write(original, writeStream);
        
        // Read back
        writeStream.Position = 0;
        var parsed = _format.Parse(writeStream, "test.properties");
        
        Assert.Equal(original.Count, parsed.Count);
        Assert.Equal(original.GetValue("app.title"), parsed.GetValue("app.title"));
        Assert.Equal(original.GetValue("app.desc"), parsed.GetValue("app.desc"));
    }
}
```

## Using Custom Formats with CLI

If you want to use your custom format with the CLI tool, you need to create a plugin:

### Step 1: Create Plugin Assembly

```csharp
// MyApp.Locale.Plugins/PropertiesFormatPlugin.cs
using Locale.Formats;

namespace MyApp.Locale.Plugins;

public class PropertiesFormatPlugin : IFormatPlugin
{
    public void Register(FormatRegistry registry)
    {
        registry.Register(new PropertiesLocalizationFormat());
    }
}
```

### Step 2: Configure Plugin Loading

Create a configuration file `.localerc` in your project root:

```json
{
  "plugins": [
    "./plugins/MyApp.Locale.Plugins.dll"
  ],
  "formats": {
    "properties": {
      "extensions": [".properties"],
      "encoding": "UTF-8"
    }
  }
}
```

### Step 3: Use with CLI

```bash
# Scan properties files
locale scan ./locales --base en --targets tr

# Convert properties to JSON
locale convert messages.properties messages.json
```

## Best Practices

1. **Inherit from `LocalizationFormatBase`** for convenience methods
2. **Implement roundtrip tests** to ensure Parse/Write fidelity
3. **Handle encoding properly** - always use UTF-8 unless format specifies otherwise
4. **Preserve comments** when possible
5. **Document limitations** - some formats can't represent all features
6. **Use appropriate exception types** - `InvalidOperationException` for malformed files
7. **Order entries** in Write for deterministic output (easier diffs)
8. **Escape special characters** properly in both directions

## Common Pitfalls

### Pitfall 1: Not Invalidating Cache

```csharp
// ❌ Wrong - doesn't invalidate cache
public List<LocalizationEntry> Entries { get; set; } = [];

// ✅ Correct - invalidates dictionary cache
public List<LocalizationEntry> Entries 
{ 
    get; 
    init
    {
        field = value;
        _entriesByKey = null;
    }
} = [];
```

### Pitfall 2: Forgetting to Sort

```csharp
// ❌ Wrong - non-deterministic output
foreach (var entry in file.Entries)
    writer.WriteLine($"{entry.Key}={entry.Value}");

// ✅ Correct - deterministic output
foreach (var entry in file.Entries.OrderBy(e => e.Key))
    writer.WriteLine($"{entry.Key}={entry.Value}");
```

### Pitfall 3: Not Handling Edge Cases

```csharp
// ✅ Always handle edge cases
public override LocalizationFile Parse(Stream stream, string? filePath = null)
{
    if (stream == null || !stream.CanRead)
        throw new ArgumentException("Stream must be readable", nameof(stream));
    
    // ... parsing logic
}
```

## Further Resources

- [ILocalizationFormat Interface](../../src/Locale/Formats/ILocalizationFormat.cs)
- [LocalizationFormatBase Base Class](../../src/Locale/Formats/LocalizationFormatBase.cs)
- [Built-in Format Examples](../../src/Locale/Formats/)
- [Format Tests](../../tests/Locale.Tests/Formats/)